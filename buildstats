#!/bin/bash

cd "$(dirname "$0")" ; here="$(pwd)"
source "$here/common"

[ "$here/console.css" -nt "$logs/console.css" ] && cp "$here/console.css" "$logs/console.css"

build_query() {
	
	local name="$1"
	local type="$2"
	
	local query=''
	
	local args
	eval "args=( \"\${!${type}[@]}\" )"
	
	for i in "${args[@]}" ; do
		if [[ "$i" =~ ^[0-9]+$ ]] || [[ "$name" == $i ]] ; then
			
			local value
			eval "value=\"\${${type}['$i']}\""
			
			if [ "$query" == '' ]
				then query="($value)"
				else query="$query|($value)"
			fi
		fi
	done
	
	echo "$query"
}

filter_log() {
	
	local file="$1"
	local name="$2"
	local type="$3"
	
	local query="$(build_query "$name" "count_$type")"
	local ignore="$(build_query "$name" "ignore_$type")"
	
	if [ "$query" == '' ] ; then
		return
	fi
	
	
	if [ -z "$ignore" ]
		then grep -P "$query" "$file" |                      sort --human-numeric-sort | uniq
		else grep -P "$query" "$file" | grep -vP "$ignore" | sort --human-numeric-sort | uniq
	fi
}

format_html() {
	html_header "$project_name: $3 build" "../.." > "$2"
	echo "<pre>" >> "$2"
	"$here/console2html.cpp" --format html < "$1" >> "$2"
	echo "</pre>" >> "$2"
	html_footer >> "$2"
}

format_plain() {
	"$here/console2html.cpp" --format plain < "$1" > "$2"
}

format() {
	if [ "$2" -nt "$3" ] || [ "$here/console2html.cpp" -nt "$3" ] ; then
		format_$1 "${@:2}"
	fi
}

is_cache_valid() {
	local cache="$1"
	local input="$2"
	[ ! "$force" = 1 ] \
		&& [ -f "$cache" ] \
		&& [ ! "$input" -nt "$cache" ] \
		&& [ ! "$here/buildstats" -nt "$cache" ] \
		&& [ ! "$here/common" -nt "$cache" ] \
		&& [ ! "$here/config" -nt "$cache" ] \
		&& [ ! "$here/config.local" -nt "$cache" ] \
		&& [ ! "$here/projects/$project" -nt "$cache" ] \
		&& [ ! "$here/projects/$project.local" -nt "$cache" ] \
		&& true
}

handle_build() {
	
	local file="$1"
	
	local path="${file%.ref}"
	local name="${path##*/}"
	
	local has_false_positives=0
	if in_wildcard_array "$name" "${false_positives[@]}" ; then
		has_false_positives=1
	fi
	
	
	local commit="$(cat "$file")"
	commits+="$commit
"
	local old_file="$path.old"
	local old_commit=''
	local old_prefix=''
	if [ -f "$old_file" ] ; then
		old_commit="$(cat "$old_file")"
		old_commits+="$old_commit
"
		old_prefix="$logs/commits/$old_commit/$name"
	fi
	
	local prefix="$logs/commits/$commit/$name"
	
	if [ ! -e "$prefix-raw.txt" ] ; then
		echo "Skipping missing/incomplete '${esc}[33m$name${esc}[0m' at commit ${esc}[34m$commit${esc}[0m"
		return
	fi
	
	local cache="$path-cache.html"
	if is_cache_valid "$cache" "$prefix-raw.txt" ; then
		local html="$(cat "$cache")
"
		if [ $has_false_positives = 0 ]
			then builds_legit+="$html"
			else builds_bogus+="$html"
		fi
		return
	fi
	
	# Produce a nice colorful html log.
	format html "$prefix-raw.txt" "$prefix.html" "$name"
		
	# Produce a plain text log without shell color codes.
	format plain "$prefix-raw.txt" "$prefix.txt" "$name"
	
	local config_warnings_file="$prefix-config-warnings.txt"
	local config_errors_file="$prefix-config-errors.txt"
	if ! is_cache_valid "$config_warnings_file" "$prefix-config.txt" ; then
		filter_log "$prefix-config.txt" "$name" config_warnings > "$config_warnings_file"
	fi
	if ! is_cache_valid "$config_errors_file" "$prefix-config.txt" ; then
		filter_log "$prefix-config.txt" "$name" config_errors > "$config_errors_file"
	fi
	local config_warnings="$(wc -l < "$config_warnings_file")"
	local config_errors="$(wc -l < "$config_errors_file")"
	
	local warnings_file="$prefix-warnings.txt"
	local errors_file="$prefix-errors.txt"
	if ! is_cache_valid "$warnings_file" "$prefix.txt" ; then
		filter_log "$prefix.txt" "$name" warnings > "$warnings_file"
	fi
	if ! is_cache_valid "$errors_file" "$prefix.txt" ; then
		filter_log "$prefix.txt" "$name" errors > "$errors_file"
	fi
	local warnings="$(wc -l < "$warnings_file")"
	local errors="$(wc -l < "$errors_file")"
	
	local time="$(grep real "$prefix-time.txt" 2> /dev/null)"
	local time="${time##* }"
	
	local minutes="$(echo "$time" | sed -r 's/^real\t(.*)m(.*)s$/\1/g')"
	local seconds="$(echo "$time" | sed -r 's/^real\t(.*)m(.*)s$/\2/g')"
	
	local dir="${file%/*}"
	local wprefix="$(relative_path "$dir" "$prefix")"
	
	local warnings_l='warnings'
	[ "$warnings" = 1 ] && warnings_l='warning&nbsp;'
	local errors_l='errors'
	[ "$errors" = 1 ] && errors_l='error&nbsp;'
	
	local config_class=''
	[ $config_warnings = 0 ] || config_class=" class='w w$config_warnings'"
	[ $config_errors = 0 ] || config_class=" class='e e$config_errors'"
	
	if ! in_array "$name" "${build_types[@]}" ; then
		disabled='obsolete'
	else
		local args
		local disabled=''
		parse_build_type "$name" 'args'
		for arg in "${args[@]}" ; do
			if in_array "$arg" "${disabled_configs[@]}" ; then
				[ -z "$disabled" ] || disabled="$disabled, "
				disabled="$disabled$arg"
			fi
		done
		[ -z "$disabled" ] || disabled="$disabled disabled"
	fi
	
	local dclass=''
	if [ ! -z "$disabled" ] ; then
		dclass=" class=\"disabled\" title=\"$disabled\""
	fi
	
	local details=''
	if [ -d "$prefix-results/" ] ; then
		details+=" [<a href=\"$wprefix-results/\">details</a>]"
	fi
	if [ ! $has_false_positives = 0 ] && [ $warnings -gt 19 ] ; then
		local warnings_dir="$prefix-warnings"
		local warnings_index="$warnings_dir/index.html"
		if ! is_cache_valid "$warnings_dir" "$warnings_file" ; then
			mkdir -p "$warnings_dir"
			local groups=(
				$(
					grep -oP '\[.*?\]( \[\d+\])?$' < "$warnings_file" | sed 's:^\[::;s:\].*$::' \
						| sort | uniq -c | sort -h | sed 's:^[ 0-9]*::'
				)
				$(
					grep -oP '\: warning [A-Z][0-9]+\:' < "$warnings_file" | sed 's:^\: warning ::;s:\:$::' \
						| sort | uniq -c | sort -h | sed 's:^[ 0-9]*::'
				)
			)
			local ungrouped_warnings="$(
				grep -Pv '(\[.*?\]( \[\d+\])?$|\: warning [A-Z][0-9]+\:)' < "$warnings_file"
			)"
			if [ ${#groups[@]} -gt 1 ] || ( [ ${#groups[@]} = 1 ] && [ ! -z "$ungrouped_warnings" ] ) ; then
				local warnings_title="$name warnings for $project_name in $type $context"
				local warnings_html="$(html_header "$warnings_title" "../../..")
	
	<h1>$warnings_title</h1>
	
	<ul>
"
				for group in "${groups[@]}" ; do
					local group_regexp="$( printf '%s' "$group" | sed 's:[^0-9a-zA-Z]:\\\0:g' )"
					local group_filename="$( printf '%s' "$group" | sed 's:[^0-9a-zA-Z_\-]:-:g;s:^-*::;s:-*$::' ).txt"
					local group_file="$warnings_dir/$group_filename"
					grep -P "(\\[$group_regexp\\]( \\[\\d+\\])?$|\\: warning $group_regexp\\:)" \
						< "$warnings_file" > "$group_file"
					local group_size="$(wc -l < "$group_file")"
					warnings_html+="		<li><a href=\"$group_filename\">$group</a> ($group_size)
"
				done
				if [ ! -z "$ungrouped_warnings" ] ; then
					printf '%s\n' "$ungrouped_warnings" > "$warnings_dir/other.txt"
					local ungrouped_size="$(printf '%s\n' "$ungrouped_warnings" | wc -l)"
					warnings_html+="		<li><a href=\"other.txt\">(ungrouped warnings)</a> ($ungrouped_size)
"
				fi
				warnings_html+="	</ul>
	
$(html_footer)"
				printf '%s\n' "$warnings_html" > "$warnings_index"
			else
				rm -f "$warnings_index"
			fi
			touch "$warnings_dir"
		fi
		if [ -f "$warnings_index" ] ; then
			details+=" [<a href=\"$wprefix-warnings/\">grouped</a>]"
		fi
	fi
	
	local primary_id=''
	local extra_ids=''
	local id="$name"
	while [ ! -z "$id" ] && [ -z "${html_ids["$id"]}" ] ; do
		if [ -z "$primary_id" ]
			then primary_id="id=\"$id\" "
			else extra_ids="<a id=\"$id\"></a>$extra_ids"
		fi
		html_ids["$id"]=1
		if [[ "$id" == *_* ]] ; then
			local part="${id##*_}"
			if [ $has_false_positives = 0 ] && [ -z "${html_ids["$part"]}" ] ; then
				extra_ids="<a id=\"$part\"></a>$extra_ids"
				html_ids["$part"]=1
			fi
			id="${id%_*}"
		elif [ $has_false_positives = 0 ] && [[ "$id" == *-* ]] ; then
			id="${id%-*}"
		else
			break
		fi
	done
	
	local html="<tr$dclass>
	<td class='n'>${extra_ids}<a ${primary_id}href=\"$wprefix.html\">$name</a>$details</td>
	<td align=right class='w w$warnings'>"
	[ $warnings -gt 0 ] && html+="<a href=\"$wprefix-warnings.txt\">"
	html+="<b>$warnings</b> $warnings_l"
	[ $warnings -gt 0 ] && html+="</a>"
	html+="</td>
	<td align=right class='e e$errors'>"
	[ $errors -gt 0 ] && html+="<a href=\"$wprefix-errors.txt\">"
	html+="<b>$errors</b> $errors_l"
	[ $errors -gt 0 ] && html+="</a>"
	html+="</td>
	<td align=right class='tm'>$minutes min</td><td align=right class='ts'>$seconds s</td>
	<td><a href=\"$wprefix.txt\">[txt]</a></td>
	<td><a href=\"$wprefix-raw.txt\">[raw]</a></td>
	<td><a href=\"$wprefix-options.txt\">[opt]</a></td>
	<td$config_class><a href=\"$wprefix-config.txt\">[cfg]</a>"
	[ $config_warnings -gt 0 ] && html+="<a href=\"$wprefix-config-warnings.txt\">[w]</a>"
	[ $config_errors -gt 0 ] && html+="<a href=\"$wprefix-config-errors.txt\">[e]</a>"
	html+="</td>"
	
	if [ ! $has_false_positives = 0 ] && [ ! -z "$old_prefix" ] ; then
		
		local change_file="$path-change.txt"
		local old_warnings_file="$old_prefix-warnings.txt"
		local old_errors_file="$old_prefix-errors.txt"
		if ! is_cache_valid "$change_file" "$here/warningdiff.cpp" \
			|| [ "$warnings_file" -nt "$change_file" ] || [ "$old_warnings_file" -nt "$change_file" ] \
			|| [ "$errors_file" -nt "$change_file" ] || [ "$old_errors_file" -nt "$change_file" ]
		then
			local change="$(
				"$here/warningdiff.cpp" "$project_name/" "$repo/.git" "$old_commit" "$old_warnings_file" "$commit" "$warnings_file"
				"$here/warningdiff.cpp" "$project_name/" "$repo/.git" "$old_commit" "$old_errors_file" "$commit" "$errors_file"
			)"
			printf '%s\n' "$change" > "$change_file"
		fi
		
		local changes=''
		local broken="$(cat "$change_file" | grep -P '^\+' | wc -l)"
		local fixed="$(cat "$change_file" | grep -P '^\-' | wc -l)"
		[ $broken = 0 ] || changes+="<span class=\"bad\">+$broken</span>"
		[ ! $broken = 0 ] && [ ! $fixed = 0 ] && changes+=' '
		[ $fixed = 0 ] || changes+="<span class=\"good\">-$fixed</span>"
		local wchange_file="$(relative_path "$dir" "$change_file")"
		if [ -z "$changes" ]
			then changes='='
			else changes="<a href="$wchange_file"><b>$changes</b></a>"
		fi
		html+="
	<td align=center>$changes</td>"
		
	elif [ ! $has_false_positives = 0 ] ; then
	
		html+="
	<td></td>"
		
	fi
	
	html+='
</tr>
'
	
	printf '%s' "$html" > "$cache"
	
	if [ $has_false_positives = 0 ]
		then builds_legit+="$html"
		else builds_bogus+="$html"
	fi
	
	echo "${esc}[34m$name${esc}[0m:   $warnings warnings,   $errors errors,   $minutes min $seconds s"
	
}

link_builds() {
	
	local name="$1"
	local dir="$2"
	local commits="$(printf '%s' "$3" | sort | uniq)"
	
	[ -z "$commits" ] && return
	
	printf '%s' "<b>$name"
	
	local comma=0
	
	for commit in $commits ; do
		
		if [ $comma = 1 ]
			then printf '%s' ", "
			else comma=1
		fi
		
		url="$(relative_path "$dir" "$logs/commits/$commit/")"
		
		timestamp="$(git --git-dir="$repo/.git" show -s --format='%ct' "$commit")"
		datetime="$(date --utc --iso-8601=seconds --date="@$timestamp")"
		time="$(date --utc --rfc-3339=seconds --date="@$timestamp")"
		time="${time%+00:00}"
		
		text="$(
			git --git-dir="$repo/.git" describe --exact-match --tags "$commit" 2> /dev/null \
			|| printf '%s' "${commit:0:6}"
		)"
		
		printf '%s' "<a href="$url">$text</a> (<time datetime=\"$datetime\">$time</time>)"
		
	done
	
	printf '%s\n' '</b><br>'
}

handle_context() {
	
	local type="$1"
	local dir="$2"
	
	[ -d "$dir" ] || return
	
	local context="${dir##*/}"
	
	local timefile="$dir/index.time"
	if ! is_cache_valid "$timefile" "$dir"
		then echo "Updating '${esc}[36m$context${esc}[0m'..."
		else return
	fi
	
	local -A html_ids
	html_ids['analyzers']=1
	html_ids['external']=1
	
	local commits=''
	local old_commits=''
	local builds_legit=''
	local builds_bogus=''
	for f in $(dir -d $dir/*.ref 2> /dev/null | sort -V) ; do
		handle_build "$f"
	done
	
	local html="$(html_header "$project_name build logs for $type $context" "../.." "
<script type=\"text/javascript\">

function nextElementSibling(e) {
	do {
		e = e.nextSibling;
	} while(e && e.nodeType != 1);
	return e;
}

function startsWith(str, needle) {
	return str.substring(0, needle.length) == needle;
}

function endsWith(str, needle) {
	return str.indexOf(needle, str.length - needle.length) !== -1;
}

function contains(str, needle) {
	return str.indexOf(needle) !== -1;
}

function isInCategory(e, id) {
	if(!e || !e.id) {
		return 0;
	}
	if(startsWith(e.id, id + '_')) {
		return 1;
	}
	if(!contains(id, '_')) {
		if(startsWith(e.id, id + '-')) {
			return 1;
		}
		if(contains(e.id, '_' + id + '_')) {
			return 2;
		}
		if(endsWith(e.id, '_' + id)) {
			return 2;
		}
	}
	return isInCategory(nextElementSibling(e), id);
}

function setCategoryClass(id, className) {
	var e = document.getElementById(id);
	if(!e || !e.parentElement || !e.parentElement.parentElement) {
		return;
	}
	var tr = e.parentElement.parentElement;
	tr.className = className;
	var contiguous = contains(id, '_') || isInCategory(nextElementSibling(e), id) != 2;
	while(tr = nextElementSibling(tr)) {
		var a = tr.firstElementChild ? tr.firstElementChild.firstElementChild : null;
		if(isInCategory(a, id)) {
			tr.className = className;
		} else if(contiguous) {
			break;
		}
	}
}

var oldid = null;
window.onload = function () {
	var newid = window.location.hash.substr(1);
	if(newid == '') {
		newid = null;
	}
	if(newid != oldid) {
		if(oldid) {
			setCategoryClass(oldid, null);
		}
		if(newid) {
			setCategoryClass(newid, 'selected');
		}
		oldid = newid;
	}
}

if('onhashchange' in window) {
	window.onhashchange = window.onload;
}

</script>")
	
	<h1>Build logs for $type "
	if [ ! -z "$commit_url" ]
		then html+="<a href="$commit_url$context">$context</a>"
		else html+="$context"
	fi
	html+="</h1>
	<a href=\"../\">Other Logs</a><br>
	<br>
"
	if [ ! "$type" = 'commit' ] ; then
		html+="$(link_builds 'Current build: ' "$dir" "$commits" | sed 's:^:\t:')"
		html+="$(link_builds 'Previous build: ' "$dir" "$old_commits" | sed 's:^:\t:')"
	fi
	
	if [ ! -z "$builds_legit" ] ; then
		html+="	
	<br>
	<table cellspacing=1 cellpadding=2 class='legit stats'>
$(printf '%s' "$builds_legit" | sed 's:^:\t\t:')
	</table>"
	fi
	
	if [ ! -z "$builds_bogus" ] ; then
		html+="	
	<h2 id=\"analyzers\">Static analyzers and other build logs that are likely to contain false positives:</h2>
	<table cellspacing=1 cellpadding=2 class='bogus stats'>
$(printf '%s' "$builds_bogus" | sed 's:^:\t\t:')
	</table>"
	fi
	
	if [ ! -z "$covertiy_scan_project$travis_ci_project$appveyor_project" ] ; then
		html+="
	<h2 id=\"external\">External tools:</h2>
	<ul>"
		if [ ! -z "$covertiy_scan_project" ] ; then
			html+="
		<li><b><a href=\"https://scan.coverity.com/projects/$covertiy_scan_project\">Coverity Scan</a></b>"
		fi
		if [ ! -z "$travis_ci_project" ] ; then
			html+="
		<li><b><a href=\"https://travis-ci.org/$travis_ci_project\">Travis CI</a></b>"
		fi
		if [ ! -z "$appveyor_project" ] ; then
			html+="
		<li><b><a href=\"https://ci.appveyor.com/project/$appveyor_project\">AppVeyor</a></b>"
		fi
		html+="
	</ul>"
	fi
	
	html+="	
$(html_footer)"
	
	local index="$dir/index.html"
	if [ ! -e "$index" ] || [ "$(cat "$index")" != "$html" ]
		then printf '%s\n' "$html" > "$index"
		else echo "${esc}[32m(no changes)${esc}[0m"
	fi
	
	if [ ! -z "$project_buildlogs_url" ] && [ "$type" = 'branch' ] ; then
		local _commits="$(printf '%s' "$commits" | sort | uniq)"
		local _buildlogs_url="${project_buildlogs_url}branches/${context}/"
		local _buildlogs_feed="$dir/feed.rss"
		echo "<?xml version=\"1.0\" encoding=\"utf-8\"?>
<rss version=\"2.0\" xmlns:atom=\"http://www.w3.org/2005/Atom\">
<channel>
<title>${project_name} build logs for branch ${context}</title>
<link>${_buildlogs_url}</link>
<description>Errors, warnings and notices for ${project_name} built with different compilers.</description>
<language>en-us</language>
<atom:link href=\"${_buildlogs_url}feed.rss\" rel=\"self\" type=\"application/rss+xml\" />" \
			> "$_buildlogs_feed"
		for commit in $_commits ; do
			local _time="$(git --git-dir="$repo/.git" show -s --format='%ct' "$commit")"
			echo "<item>
<title>${project_name} build logs for branch ${context} updated to ${commit}</title>
<link>${_buildlogs_url}</link>
<pubDate>$(date --rfc-2822 --utc --date="@${_time}")</pubDate>
<guid>${project_buildlogs_url}commits/${commit}/</guid>
</item>" >> "$_buildlogs_feed"
		done
		echo '</channel>
</rss>' >> "$_buildlogs_feed"
		touch --reference="$index" "$_buildlogs_feed"
	fi
	
	touch "$timefile"
}

echo "Updating indices..."

for f in $(dir -d $logs/commits/* 2> /dev/null) ; do
	handle_context 'commit' "$f"
done

for f in $(dir -d $logs/branches/* 2> /dev/null) ; do
	handle_context 'branch' "$f"
done

echo "Done."

#!/bin/bash

cd "$(dirname "$0")" ; here="$(pwd)"
source "$here/common"

echo 'Updating repo...'
cd "$repo" || die "unable to cd to repository at $repo"
if [ $fetch = 1 ] ; then git fetch || die "git fetch failed" ; fi
git remote prune origin &> /dev/null || die "failed to prune repository"

# Initialize the output directory.
mkdir "$logs" &> /dev/null
mkdir "$bin" &> /dev/null
mkdir "$logs/branches" &> /dev/null
mkdir "$logs/commits" &> /dev/null
mkdir "$bin/branches" &> /dev/null
mkdir "$bin/commits" &> /dev/null

my_replace() {
	replace "/mnt/overflow$1" "$2" \
	         "Z:$(printf '%s' "$1" | tr '/' '\\')" "$2" \
	         "z:$(printf '%s' "$1" | tr '/' '\\')" "$2" \
	         "Z:$(printf '%s' "$1" | sed 's:/:\\\\:g')" "$2" \
	         "z:$(printf '%s' "$1" | sed 's:/:\\\\:g')" "$2" \
	         "$1" "$2"
}

# Shorten long paths and make them independent of where arxbuild is installed.
process_paths() {
	my_replace "$build"             "Build" | \
	my_replace "$repo"              "$project_name"  | \
	my_replace "$toolchains"        "Toolchains" | \
	my_replace "$deps/msvc/drive_c" "C:" | \
	my_replace "$deps"              "Deps" | \
	my_replace "$here/"             ""
}

# Remove header and footer created by the script command.
descript() {
	sed -e '$d;1d' | sed -e '$d'
}

make_helper() {
	script -c "$1" "$2" &> /dev/null
}

timed_make() {
	time make_helper "$1" "$2"
}

escape() {
	printf '%s' "$1" | sed "s:[^a-zA-Z0-9/_.=-]:\\\\&:g"
}

escape_args() {
	local prefix=''
	for arg in "$@" ; do
		printf "$prefix"
		escape "$arg"
		prefix=' '
	done
}

msvc_started=0

set_branch_commit() {
	local branch_dst="$1"
	local buildid="$2"
	local commit="$3"
	
	local bin_branch="$branch_bindst/$buildid"
	local bin_commit="$commit_bindst/$buildid"
	if [ -e "$bin_commit" ] \
		&& ( [ ! -e "$bin_branch" ] \
		  || [ "$(readlink -f "$bin_branch")" != "$(readlink -f "$bin_commit")" ] \
		) ; then
		rm "$bin_branch" &> /dev/null
		ln -s --relative "$bin_commit" "$bin_branch"
		touch "$branch_bindst"
	fi
	
	local ref_branch="$branch_dst/$buildid.ref"
	local old_branch="$branch_dst/$buildid.old"
	if [ -e "$ref_branch" ] ; then
		local old_commit="$(cat "$ref_branch")"
		[ "$old_commit" = "$commit" ] && return # nothing changed
		mv "$ref_branch" "$old_branch"
	fi
	echo "$commit" > "$ref_branch"
	touch "$branch_dst"
}

build() {
	
	local compiler="$1"
	buildid="${compiler}"
	
	local options="${cmake_options[$compiler]}"
	local flags="${compiler_options[$compiler]}"
	local ldflags="${linker_options[$compiler]}"
	local prefixes="${prefix_paths[$compiler]}"
	
	if [ ! -z "$default_cmake_options" ] ; then
		[ ! -z "$options" ] && local options="$options "
		local options="$options$default_cmake_options"
	fi
	
	for arg in "${@:2}" ; do
		
		local buildid="${buildid}_$arg"
		
		if [ "${cmake_options[$arg]}" != "" ] ; then
			[ "$options" != "" ] && local options="$options "
			local options="$options${cmake_options[$arg]}"
		fi
		
		if [ "${compiler_options[$arg]}" != "" ] ; then
			[ "$flags" != "" ] && local flags="$flags "
			local flags="$flags${compiler_options[$arg]}"
		fi
		
		if [ "${linker_options[$arg]}" != "" ] ; then
			[ "$ldflags" != "" ] && local ldflags="$ldflags "
			local ldflags="$ldflags${linker_options[$arg]}"
		fi
		
		if [ "${prefix_paths[$arg]}" != "" ] ; then
			[ "$prefixes" != "" ] && local prefixes="$prefixes;"
			local prefixes="$prefixes${prefix_paths[$arg]}"
		fi
		
	done
	
	if [ "$flags" != "" ] ; then
		local options="$options \"-DCMAKE_C_FLAGS=$flags\" \"-DCMAKE_CXX_FLAGS=$flags\""
	fi
	
	if [ "$ldflags" != "" ] ; then
		local options="$options \"-DCMAKE_EXE_LINKER_FLAGS=$ldflags\" \"-DCMAKE_SHARED_LINKER_FLAGS=$ldflags\" \"-DCMAKE_MODULE_LINKER_FLAGS=$ldflags\""
	fi
	
	if [ "$prefixes" != "" ] ; then
		local options="$options \"-DCMAKE_PREFIX_PATH=$prefixes\""
	fi
	
	local ref_commit="$commit_dst/$buildid.ref"
	local force_commit="$commit_dst/$buildid.force"
	if [ -e "$ref_commit" ] && [ ! -e "$force_commit" ] ; then
		set_branch_commit "$branch_dst" "$buildid" "$commit"
		return
	fi
	
	echo "${esc}[32m[$buildid]${esc}[0m"
	
	case "$compiler" in msvc-*) if [ $msvc_started = 0 ] ; then
		echo "${esc}[36mStarting MSVC environment${esc}[0m"
		"$toolchains/msvcrun" --start
		msvc_started=1
	fi ; esac
	
	
	# Clear the build directory.
	find "$build" -mindepth 1 -delete
	rm -r "$repo/bin" &> /dev/null
	
	# Final log file locations.
	[ -d "$stage" ] || mkdir "$stage" || die "Could not create stage directory!"
	find "$stage" -mindepth 1 -delete
	local dst_raw="$stage/$buildid-raw.txt"
	local dst_config="$stage/$buildid-config.txt"
	local dst_options="$stage/$buildid-options.txt"
	local dst_time="$stage/$buildid-time.txt"
	
	cd "$build"
	
	local do_build=1
	
	local _config_required="${config_required[$compiler]:-1}"
	
	local log_build="$stage/buildlog.script"
	local log_config="$stage/config.log"
	
	if [ ! "$_config_required" = 0 ] ; then
		echo 'Configuring...'
		local cmake_args="$(escape "$repo/$path") -DCMAKE_INSTALL_PREFIX=/ $options"
		if ! eval "cmake --no-warn-unused-cli $cmake_args" &> "$log_config" ; then
			echo "${esc}[31mConfigure failed!${esc}[0m"
			echo -e "\nConfigure.h:0:0: error: Configure error, see config log.\n\n" > "$log_build"
			do_build=0
		fi
	fi
	
	local _make_command="$(eval escape_args "${make_command[$compiler]:-"make -k"}")"
	if [ $do_build = 1 ] ; then
		
		echo 'Building...'
		timed_make "$_make_command" "$log_build" &> "$dst_time"
		
		if [ "$(grep "make\\: \\*\\*\\* \\[[a-z]*\\] Interrupt" "$log_build")" ] ; then
			die "Build cancelled!"
		fi
		
		# Save the resulting binaries.
		rm -rf "$commit_bindst/$buildid" &> /dev/null
		mkdir "$commit_bindst/$buildid" &> /dev/null
		
		if [ "$_make_command" = 'make' ] || [ "$_make_command" = 'make -k' ] ; then
			DESTDIR="$commit_bindst/$buildid/" make -k install &> /dev/null
		fi
		
	fi
	
	echo 'Processing...'
	
	# Save the cmake output and used options.
	if [ ! "$_config_required" = 0 ] ; then
		process_paths < "$log_config" > "$dst_config"
		echo "$options" | process_paths > "$dst_options"
	else
		echo "no config step" > "$dst_config"
		echo "$_make_command" | process_paths > "$dst_options"
	fi
	
	# Process the raw shell-colored log.
	if [ "${process[$compiler]}" ]
		then descript < "$log_build" | process_paths | "${process[$compiler]}" > "$dst_raw"
		else descript < "$log_build" | process_paths > "$dst_raw"
	fi
	
	
	# Record build for branch
	touch "$branch_dst"
	set_branch_commit "$branch_dst" "$buildid" "$commit"
	
	# Record build for commit
	touch "$commit_dst"
	[ -e "$ref_commit" ] && rm "$ref_commit"
	mv "$stage/$buildid"* "$commit_dst/"
	echo "$commit" > "$ref_commit"
	[ -e "$force_commit" ] && rm "$force_commit"
	
	# Update statistics and indices.
	"$here/buildstats" "$project" &> /dev/null
	
}

build_branch() {
	
	branch="$1"
	
	# Abort if the branch is empty
	if [ ! "$branch" ] ; then return ; fi
	
	cd "$repo"
	git reset --hard &> /dev/null
	git checkout "origin/$branch" &> /dev/null \
		|| git checkout "tags/$branch" &> /dev/null \
		|| die "error checking out branch $branch"
	
	commit=`cat "$repo/.git/HEAD"`
	
	# Abort if the commit is empty
	if [ ! "$commit" ] ; then return ; fi
		
	echo "Checked out branch ${esc}[36m'$branch'${esc}[0m at commit ${esc}[34m$commit${esc}[0m"
	
	# Prepare the output directories.
	branch_dst="$logs/branches/$branch"
	commit_dst="$logs/commits/$commit"
	mkdir "$branch_dst" &> /dev/null
	mkdir "$commit_dst" &> /dev/null
	branch_bindst="$bin/branches/$branch"
	commit_bindst="$bin/commits/$commit"
	mkdir "$branch_bindst" &> /dev/null
	mkdir "$commit_bindst" &> /dev/null
	
	echo "file://$branch_dst/index.html"
	
	# Build with different configurations.
	
	for build_type in "${build_types[@]}" ; do
		
		local args;
		parse_build_type "$build_type" 'args'
		
		build "${args[@]}"
		
	done
	
	#build_types
}

if [ $build_latest_tag = 1 ] ; then
	latest_tag="$(
		git --git-dir="$repo/.git" describe --tags $(git --git-dir="$repo/.git" rev-list --tags --max-count=1)
	)"
	[ -z "$latest_tag" ] || build_branch "$latest_tag"
fi

# Build all remote branches.
for f in `dir -d $repo/.git/logs/refs/remotes/origin/* 2> /dev/null` ; do
	branch="${f##*/}"
	
	if in_array "$branch" "${ignored_branches[@]}" ; then
		# Ignore this branch
		continue
	fi
	
	build_branch "$branch"
done

if [ $msvc_started = 1 ] ; then
	echo "${esc}[36mStopping MSVC environment${esc}[0m"
	"$toolchains/msvcrun" --stop
	msvc_started=0
fi

echo "Done, logs saved to $logs"

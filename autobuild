#!/bin/bash

cd "$(dirname "$0")"
here="$(pwd)"

source "$here/common"

# Build the tools if needed.
if [ -e "$here/console2html.cpp" ] && ( [ ! -e "$here/console2html" ] || [ "$here/console2html.cpp" -nt "$here/console2html" ] ) ; then
	echo 'Building tools..'
	g++ "$here/console2html.cpp" -o "$here/console2html"
fi

echo 'Updating repo...'
cd "$repo" || exit
git fetch || exit
git remote prune origin &> /dev/null || exit

# Initialize the output directory.
mkdir "$logs" &> /dev/null
mkdir "$bin" &> /dev/null
mkdir "$logs/branches" &> /dev/null
mkdir "$logs/commits" &> /dev/null
mkdir "$bin/branches" &> /dev/null
mkdir "$bin/commits" &> /dev/null
cp "$here/console.css" "$logs/console.css"

# Shorten long paths and make them independent of where arxbuild is installed.
function process_paths() {
	replace "$build" "Build" "$repo" "$project_name" "$toolchains" "Toolchains" "$here/" ""
}

# Remove header and footer created by the script command.
function descript() {
	sed -e '$d;1d' | sed -e '$d'
}

function make_helper() {
	script -c "make -k $1" "$log_build" &> /dev/null
}

function timed_make() {
	time make_helper "$1"
}

function build_cancelled() {
	rm $commit_dst/$buildid.* &> /dev/null
	rm $commit_dst/$buildid-* &> /dev/null
	rm $branch_dst/$buildid.* &> /dev/null
	rm $branch_dst/$buildid-* &> /dev/null
	echo 'Build cancelled!'; exit
}

function build() {
	
	local compiler="$1"
	buildid="${compiler}"
	
	local options="${cmake_options[$compiler]}"
	local flags="${compiler_options[$compiler]}"
	local targets="${make_options[$compiler]}"
	
	for arg in "${@:2}" ; do
		
		local buildid="${buildid}_$arg"
		
		if [ "${cmake_options[$arg]}" != "" ] ; then
			if [ "$options" != "" ] ; then
				local options="$options "
			fi
			local options="$options${cmake_options[$arg]}"
		fi
		
		if [ "${compiler_options[$arg]}" != "" ] ; then
			if [ "$flags" != "" ] ; then
				local flags="$flags "
			fi
			local flags="$flags${compiler_options[$arg]}"
		fi
		
		if [ "${make_options[$arg]}" != "" ] ; then
			if [ "$targets" != "" ] ; then
				local targets="$targets "
			fi
			local targets="$targets${make_options[$arg]}"
		fi
		
	done
	
	if [ "$flags" != "" ] ; then
		local options="$options \"-DCMAKE_C_FLAGS=$flags\" \"-DCMAKE_CXX_FLAGS=$flags\""
	fi
	
	local ref_branch="$branch_dst/$buildid.ref"
	local ref_commit="$commit_dst/$buildid.ref"
	
	trap "build_cancelled" SIGHUP SIGINT SIGTERM
	
	if [ -e "$ref_commit" ] ; then
		# Build already exists.
		if [ "$branch_dst" ] && ( [ ! -e "$ref_branch" ] || [ `cat "$ref_branch"` != "$commit" ] ) ; then
			# Record this in the branch anyway.
			echo "$commit" > "$ref_branch"
			touch "$branch_dst"
			"$here/buildstats" &> /dev/null
		fi
		if [ "$branch_bindst" ] && [ -e "$commit_bindst/$buildid" ] ; then
			rm "$branch_bindst/$buildid" &> /dev/null
			ln -s "$commit_bindst/$buildid" "$branch_bindst/$buildid"
		fi
		return
		else echo "$commit" > "$ref_commit"
	fi
	
	[ ! "$branch_dst" ] || echo "$commit" > "$ref_branch"
	
	echo "${esc}[32m[$buildid]${esc}[0m"
	
	# Final log file locations.
	local dst_raw="$commit_dst/$buildid-raw.txt"
	local dst_html="$commit_dst/$buildid.htm"
	local dst_plain="$commit_dst/$buildid.txt"
	local dst_config="$commit_dst/$buildid-config.txt"
	local dst_options="$commit_dst/$buildid-options.txt"
	local dst_time="$commit_dst/$buildid-time.txt"
	
	# Clear the build directory.
	find "$build" -mindepth 1 -delete
	rm -r "$repo/bin" &> /dev/null
	
	echo 'Configuring...'
	if cd "$build" && eval "cmake \"$repo/$path\" $options" &> "$log_config" ; then
		
		echo 'Building...'
		timed_make "$targets" &> "$dst_time"
		
		if [ "$(grep "make\\: \\*\\*\\* \\[[a-z]*\\] Interrupt" "$log_build")" ] ; then
			build_cancelled
		fi
		
		# Save the resulting binaries.
		rm -rf "$commit_bindst/$buildid" &> /dev/null
		mkdir "$commit_bindst/$buildid" &> /dev/null
		
		for binary in "${binaries[@]}" ; do
			mv "$build/$binary" "$commit_bindst/$buildid/" &> /dev/null
		done
		
		rm "$branch_bindst/$buildid" &> /dev/null
		ln -s "$commit_bindst/$buildid" "$branch_bindst/$buildid"
		
	else
		
		echo "${esc}[31mConfigure failed!${esc}[0m"
		echo -e "\nConfigure.h:0:0: error: Configure error, see config log.\n\n" > "$log_build"
		
	fi
	
	echo 'Processing...'
	
	# Save the cmake output and used options.
	process_paths < "$log_config" > "$dst_config"
	echo "$options" | process_paths > "$dst_options"
	
	# Process the raw shell-colored log.
	if [ "${process[$compiler]}" ]
		then descript < "$log_build" | process_paths | "${process[$compiler]}" > "$dst_raw"
		else descript < "$log_build" | process_paths > "$dst_raw"
	fi
	
	# Produce a nice colorful html log.
	html_header "$buildid" "../.." > "$dst_html"
	echo "<pre>" >> "$dst_html"
	"$here/console2html" < "$dst_raw" >> "$dst_html"
	echo "</pre>" >> "$dst_html"
	html_footer >> "$dst_html"
	
	# Produce a plain text log without shell color codes.
	sed -r "s/${esc}\\[[0-9]*(\\;[0-9]*)*m//g" "$dst_raw" > "$dst_plain"
	
	# Update statistics and indices.
	touch "$commit_dst"
	touch "$branch_dst"
	"$here/buildstats" &> /dev/null
	
	trap "echo 'Cancelled!'; exit" SIGHUP SIGINT SIGTERM
	
}

function build_branch() {
	
	branch="$1"
	
	# Abort if the branch is empty
	if [ ! "$branch" ] ; then return ; fi
	
	cd "$repo"
	git checkout "origin/$branch" &> /dev/null || ( echo "error checking out branch $branch" ; return )
	
	commit=`cat "$repo/.git/HEAD"`
	
	# Abort if the commit is empty
	if [ ! "$commit" ] ; then return ; fi
		
	echo "Checked out branch ${esc}[36m'$branch'${esc}[0m at commit ${esc}[34m$commit${esc}[0m"
	
	# Prepare the output directories.
	branch_dst="$logs/branches/$branch"
	commit_dst="$logs/commits/$commit"
	mkdir "$branch_dst" &> /dev/null
	mkdir "$commit_dst" &> /dev/null
	branch_bindst="$bin/branches/$branch"
	commit_bindst="$bin/commits/$commit"
	mkdir "$branch_bindst" &> /dev/null
	mkdir "$commit_bindst" &> /dev/null
	
	# Build with different configurations.
	
	for build_type in "${build_types[@]}" ; do
		
		local args;
		parse_build_type "$build_type" 'args'
		
		build "${args[@]}"
		
	done
	
	#build_types
}

# Build all remote branches.
for f in `dir -d $repo/.git/logs/refs/remotes/origin/* 2> /dev/null` ; do
	branch="${f##*/}"
	build_branch "$branch"
done

echo "Done, logs saved to $logs"
